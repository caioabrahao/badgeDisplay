<!DOCTYPE html>
<html>
<head>
    <title>3D Badges</title>
    <style>
        body { margin: 0; background: transparent; }
        canvas { display: block; }
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-family: monospace;
            display: none;
        }
    </style>
</head>
<body>
    <div id="debug-info"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Debug elements
        let debugMode = false;
        const debugInfo = document.getElementById('debug-info');
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        const axesHelper = new THREE.AxesHelper(5);
        const gridHelper = new THREE.GridHelper(10, 10);
        
        controls.enabled = false;

        // Create badges
        const badges = [];
        const badgeGeometry = new THREE.CylinderGeometry(1, 1, 0.2, 32);
        const materials = [
            new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                wireframe: true,
                wireframeLinewidth: 2
            }),
            new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                wireframe: true,
                wireframeLinewidth: 2
            }),
            new THREE.MeshBasicMaterial({ 
                color: 0x0000ff, 
                wireframe: true,
                wireframeLinewidth: 2
            })
        ];

        for (let i = 0; i < 3; i++) {
            const badge = new THREE.Mesh(badgeGeometry, materials[i]);
            badge.position.x = (i - 1) * 3;
            // Rotate to face camera
            badge.rotation.x = Math.PI / 2;
            badge.userData = {
                originalScale: 1,
                isAnimating: false,
                rotationProgress: 0
            };
            badges.push(badge);
            scene.add(badge);
        }

        // Store initial camera state
        const defaultCameraState = {
            position: new THREE.Vector3(0, 0, 8),
            target: new THREE.Vector3(0, 0, 0),
            up: new THREE.Vector3(0, 1, 0)
        };

        // Set initial camera position
        camera.position.copy(defaultCameraState.position);
        camera.lookAt(defaultCameraState.target);
        camera.up.copy(defaultCameraState.up);

        // Mouse interaction setup
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(badges);
            
            if (intersects.length > 0) {
                const badge = intersects[0].object;
                if (!badge.userData.isAnimating) {
                    badge.userData.isAnimating = true;
                    badge.userData.rotationProgress = 0;
                }
            }
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            controls.enabled = debugMode;
            debugInfo.style.display = debugMode ? 'block' : 'none';
            axesHelper.visible = debugMode;
            gridHelper.visible = debugMode;
        }

        // Reset function
        function resetCamera() {
            camera.position.copy(defaultCameraState.position);
            camera.lookAt(defaultCameraState.target);
            camera.up.copy(defaultCameraState.up);
            
            if (controls) {
                controls.target.copy(defaultCameraState.target);
                controls.update();
            }
        }

        // Event listeners
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onClick);
        window.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'd': // Toggle debug mode
                    toggleDebugMode();
                    break;
                case 'r': // Reset camera
                    resetCamera();
                    break;
            }
        });

        function updateDebugInfo() {
            if (!debugMode) return;
            debugInfo.innerHTML = `
                Camera Position:
                X: ${camera.position.x.toFixed(2)}
                Y: ${camera.position.y.toFixed(2)}
                Z: ${camera.position.z.toFixed(2)}
            `.replace(/\n/g, '<br>');
        }

        function animate() {
            requestAnimationFrame(animate);
            if (debugMode) controls.update();
            updateDebugInfo();

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(badges);
            
            badges.forEach(badge => {
                // Hover effect
                if (intersects.length > 0 && intersects[0].object === badge) {
                    badge.scale.lerp(new THREE.Vector3(1.5, 1.5, 1.5), 0.1);
                } else {
                    badge.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                }

                // Spin animation
                if (badge.userData.isAnimating) {
                    badge.userData.rotationProgress += 0.15;
                    badge.rotation.x = Math.PI / 2 + badge.userData.rotationProgress;

                    if (badge.userData.rotationProgress >= Math.PI * 2) {
                        badge.userData.isAnimating = false;
                        badge.userData.rotationProgress = 0;
                        badge.rotation.x = Math.PI / 2;
                    }
                }
            });

            renderer.render(scene, camera);
        }

        // Add helpers to scene but initially hide them
        scene.add(axesHelper);
        scene.add(gridHelper);
        axesHelper.visible = false;
        gridHelper.visible = false;

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html> 